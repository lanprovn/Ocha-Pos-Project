generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String              @id @default(uuid())
  email         String              @unique
  password      String
  name          String
  role          UserRole            @default(STAFF)
  isActive      Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  cancellations OrderCancellation[]
  returns       OrderReturn[]
  orderSplits   OrderSplit[]
  orderMerges   OrderMerge[]

  @@map("users")
}

model Category {
  id          String    @id @default(uuid())
  name        String
  image       String?
  description String?
  icon        String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  products    Product[]

  @@map("categories")
}

model Product {
  id           String             @id @default(uuid())
  name         String
  description  String?
  price        Decimal            @db.Decimal(10, 2)
  categoryId   String?
  image        String?
  rating       Decimal?           @db.Decimal(3, 2)
  discount     Decimal?           @db.Decimal(5, 2)
  stock        Int                @default(0)
  isAvailable  Boolean            @default(true)
  isPopular    Boolean            @default(false)
  tags         String[]
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  orderItems   OrderItem[]
  recipes      ProductRecipe[]
  sizes        ProductSize[]
  toppings     ProductTopping[]
  category     Category?          @relation(fields: [categoryId], references: [id])
  stockData    Stock?
  alerts       StockAlert[]
  transactions StockTransaction[]

  @@index([categoryId])
  @@index([isAvailable])
  @@index([isPopular])
  @@index([createdAt])
  @@index([categoryId, isAvailable])
  @@map("products")
}

model ProductSize {
  id         String   @id @default(uuid())
  productId  String
  name       String
  extraPrice Decimal  @default(0) @db.Decimal(10, 2)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@map("product_sizes")
}

model ProductTopping {
  id         String   @id @default(uuid())
  productId  String
  name       String
  extraPrice Decimal  @default(0) @db.Decimal(10, 2)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@map("product_toppings")
}

model Order {
  id                   String                 @id @default(uuid())
  orderNumber          String                 @unique
  status               OrderStatus            @default(PENDING)
  totalAmount          Decimal                @db.Decimal(10, 2)
  customerName         String?
  customerPhone        String?
  customerTable        String?
  notes                String?
  paymentMethod        PaymentMethod?
  paymentStatus        PaymentStatus          @default(PENDING)
  orderCreator         OrderCreator?          @default(STAFF)
  orderCreatorName     String?
  paidAt               DateTime?
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  paymentDate          DateTime?
  paymentTransactionId String?
  customerId           String?
  confirmedBy          String?
  confirmedAt          DateTime?
  holdName             String? // Tên đơn hàng khi lưu tạm
  loyalty_transactions loyalty_transactions[]
  items                OrderItem[]
  customers            customers?             @relation(fields: [customerId], references: [id])
  cancellation         OrderCancellation?
  returns              OrderReturn[]
  originalSplits       OrderSplit[]           @relation("OriginalOrder")
  splitOrders          OrderSplit[]           @relation("SplitOrder")
  originalMerges       OrderMerge[]           @relation("OriginalOrder")
  mergedOrders         OrderMerge[]           @relation("MergedOrder")

  @@index([status])
  @@index([createdAt])
  @@index([paymentStatus])
  @@index([status, createdAt])
  @@index([customerPhone])
  @@index([orderCreator])
  @@index([customerId])
  @@index([status, orderCreator])
  @@map("orders")
}

model OrderItem {
  id               String            @id @default(uuid())
  orderId          String
  productId        String
  quantity         Int
  price            Decimal           @db.Decimal(10, 2)
  subtotal         Decimal           @db.Decimal(10, 2)
  selectedSize     String?
  selectedToppings String[]
  note             String?
  createdAt        DateTime          @default(now())
  order            Order             @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product          Product           @relation(fields: [productId], references: [id])
  returnItems      OrderReturnItem[]

  @@index([orderId])
  @@index([productId])
  @@index([orderId, productId])
  @@map("order_items")
}

model Ingredient {
  id           String             @id @default(uuid())
  name         String
  unit         String
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  stock        IngredientStock?
  recipes      ProductRecipe[]
  alerts       StockAlert[]
  transactions StockTransaction[]

  @@map("ingredients")
}

model Stock {
  id          String   @id @default(uuid())
  productId   String   @unique
  quantity    Int      @default(0)
  minStock    Int      @default(0)
  maxStock    Int      @default(0)
  unit        String   @default("pcs")
  isActive    Boolean  @default(true)
  lastUpdated DateTime @default(now())
  createdAt   DateTime @default(now())
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@map("stock")
}

model IngredientStock {
  id           String     @id @default(uuid())
  ingredientId String     @unique
  quantity     Int        @default(0)
  minStock     Int        @default(0)
  maxStock     Int        @default(0)
  isActive     Boolean    @default(true)
  lastUpdated  DateTime   @default(now())
  createdAt    DateTime   @default(now())
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

  @@map("ingredient_stocks")
}

model ProductRecipe {
  id           String     @id @default(uuid())
  productId    String
  ingredientId String
  quantity     Decimal    @db.Decimal(10, 3)
  unit         String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  ingredient   Ingredient @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  product      Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, ingredientId])
  @@map("product_recipes")
}

model StockTransaction {
  id           String               @id @default(uuid())
  productId    String?
  ingredientId String?
  type         StockTransactionType
  quantity     Int
  reason       String?
  userId       String?
  timestamp    DateTime             @default(now())
  ingredient   Ingredient?          @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  product      Product?             @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([timestamp])
  @@index([type])
  @@index([productId, timestamp])
  @@index([ingredientId, timestamp])
  @@index([userId])
  @@map("stock_transactions")
}

model StockAlert {
  id           String         @id @default(uuid())
  productId    String?
  ingredientId String?
  type         StockAlertType
  message      String
  isRead       Boolean        @default(false)
  timestamp    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  ingredient   Ingredient?    @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
  product      Product?       @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([isRead])
  @@index([timestamp])
  @@index([type])
  @@index([productId, isRead])
  @@index([ingredientId, isRead])
  @@map("stock_alerts")
}

model customers {
  id                   String                 @id
  name                 String
  phone                String                 @unique
  email                String?                @unique
  address              String?
  dateOfBirth          DateTime?
  gender               String?
  avatar               String?
  loyaltyPoints        Int                    @default(0)
  membershipLevel      MembershipLevel        @default(BRONZE)
  totalSpent           Decimal                @default(0) @db.Decimal(10, 2)
  notes                String?
  tags                 String[]
  isActive             Boolean                @default(true)
  createdAt            DateTime               @default(now())
  updatedAt            DateTime
  lastVisitAt          DateTime?
  loyalty_transactions loyalty_transactions[]
  orders               Order[]

  @@index([email])
  @@index([isActive])
  @@index([membershipLevel])
  @@index([phone])
}

model loyalty_transactions {
  id         String                 @id
  customerId String
  orderId    String?
  type       LoyaltyTransactionType
  points     Int
  reason     String?
  createdAt  DateTime               @default(now())
  customers  customers              @relation(fields: [customerId], references: [id], onDelete: Cascade)
  orders     Order?                 @relation(fields: [orderId], references: [id])

  @@index([createdAt])
  @@index([customerId])
  @@index([orderId])
  @@index([type])
}

enum UserRole {
  ADMIN
  STAFF
  CUSTOMER
}

enum OrderStatus {
  CREATING
  PENDING
  HOLD
  CONFIRMED
  PREPARING
  READY
  COMPLETED
  CANCELLED
}

enum PaymentMethod {
  CASH
  QR
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
}

enum OrderCreator {
  STAFF
  CUSTOMER
}

enum StockTransactionType {
  SALE
  PURCHASE
  ADJUSTMENT
  RETURN
}

enum StockAlertType {
  LOW_STOCK
  OUT_OF_STOCK
  OVERSTOCK
}

enum LoyaltyTransactionType {
  EARN
  REDEEM
  EXPIRED
  ADJUSTMENT
}

enum MembershipLevel {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

// ===== Order Management Models =====

model OrderCancellation {
  id           String   @id @default(uuid())
  orderId      String   @unique
  reason       String
  reasonType   String // OUT_OF_STOCK, CUSTOMER_REQUEST, SYSTEM_ERROR, OTHER
  refundAmount Decimal? @db.Decimal(10, 2)
  refundMethod String? // CASH, CARD, QR
  refundStatus String?  @default("PENDING") // PENDING, COMPLETED, FAILED
  cancelledBy  String
  cancelledAt  DateTime @default(now())
  notes        String?

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [cancelledBy], references: [id])

  @@index([orderId])
  @@index([cancelledBy])
  @@index([cancelledAt])
  @@index([reasonType])
  @@map("order_cancellations")
}

model OrderReturn {
  id           String   @id @default(uuid())
  orderId      String
  returnType   String // FULL, PARTIAL
  returnReason String // DEFECTIVE, WRONG_ITEM, CUSTOMER_REQUEST, OTHER
  refundAmount Decimal  @db.Decimal(10, 2)
  refundMethod String // CASH, CARD, QR
  refundStatus String   @default("PENDING") // PENDING, COMPLETED, FAILED
  returnedBy   String
  returnedAt   DateTime @default(now())
  notes        String?

  items OrderReturnItem[]
  order Order             @relation(fields: [orderId], references: [id])
  user  User              @relation(fields: [returnedBy], references: [id])

  @@index([orderId])
  @@index([returnedBy])
  @@index([returnedAt])
  @@index([returnType])
  @@map("order_returns")
}

model OrderReturnItem {
  id           String  @id @default(uuid())
  returnId     String
  orderItemId  String
  quantity     Int // Số lượng đổi trả
  refundAmount Decimal @db.Decimal(10, 2)

  return    OrderReturn @relation(fields: [returnId], references: [id], onDelete: Cascade)
  orderItem OrderItem   @relation(fields: [orderItemId], references: [id])

  @@index([returnId])
  @@index([orderItemId])
  @@map("order_return_items")
}

model OrderSplit {
  id              String   @id @default(uuid())
  originalOrderId String // Đơn hàng gốc
  splitOrderId    String // Đơn hàng đã chia
  splitBy         String // User ID
  splitAt         DateTime @default(now())

  originalOrder Order @relation("OriginalOrder", fields: [originalOrderId], references: [id], onDelete: Cascade)
  splitOrder    Order @relation("SplitOrder", fields: [splitOrderId], references: [id], onDelete: Cascade)
  user          User  @relation(fields: [splitBy], references: [id])

  @@unique([originalOrderId, splitOrderId])
  @@index([originalOrderId])
  @@index([splitOrderId])
  @@index([splitBy])
  @@map("order_splits")
}

model OrderMerge {
  id              String   @id @default(uuid())
  mergedOrderId   String // Đơn hàng sau khi gộp
  originalOrderId String // Đơn hàng gốc (một trong các đơn được gộp)
  mergedBy        String // User ID
  mergedAt        DateTime @default(now())

  mergedOrder   Order @relation("MergedOrder", fields: [mergedOrderId], references: [id], onDelete: Cascade)
  originalOrder Order @relation("OriginalOrder", fields: [originalOrderId], references: [id], onDelete: Cascade)
  user          User  @relation(fields: [mergedBy], references: [id])

  @@index([mergedOrderId])
  @@index([originalOrderId])
  @@index([mergedBy])
  @@map("order_merges")
}
