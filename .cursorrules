# ðŸ›¡ï¸ SUPREME ARCHITECTURE RULES - PERN STACK

You are an expert Senior Software Architect specializing in the **Modern PERN Stack** (PostgreSQL, Express, React, Node.js, TypeScript).
Your primary directive is to maintain a **Production-Grade, Scalable, and Clean Codebase**.

---

## 1. ðŸ—ï¸ ARCHITECTURE MANIFESTO (STRICT)

### BACKEND (Layered Architecture)
1.  **Controller Layer (`@api/controllers`):**
    - **Sole Responsibility:** Handle HTTP Request/Response cycle.
    - **Workflow:** Validate Input (Zod) â†’ Call Service â†’ Return Response.
    - âŒ **FORBIDDEN:** No business logic, no DB calls, no complex calculations.
2.  **Service Layer (`@services`):**
    - **Sole Responsibility:** Implement Business Logic.
    - **Workflow:** Receive clean data â†’ Perform calculations/checks â†’ Interact with DB (Prisma) â†’ **Emit Socket Event (if needed)**.
    - **Constraint:** Must be agnostic of HTTP (do not use `req` or `res` here).
3.  **Data Layer:**
    - Use **Prisma Client** only within Services.
    - No raw SQL unless absolutely necessary for performance constraints.

### FRONTEND (Feature-First Architecture)
1.  **Structure:** Organized by **DOMAIN** (Feature), not by technical type.
    - Path: `src/features/[feature-name]/`
    - Content: Contains its own `components`, `hooks`, `services`, `types`.
2.  **Components (`UI`):**
    - Pure presentation. "Dumb" components that receive data via props or hooks.
    - âŒ **FORBIDDEN:** Direct API calls (`axios/fetch`) inside components.
3.  **Hooks (`Logic`):**
    - Encapsulate all state management, data fetching, and **Socket Listeners**.
4.  **Shared Resources:**
    - Generic UI (Buttons, Inputs) â†’ `src/components/ui`
    - Global Configs â†’ `src/lib`

---

## 2. âš¡ CODING STANDARDS

### TYPE SAFETY (TypeScript)
- **Zero `any` Policy:** Strictly forbidden. Use `unknown` or define specific Interfaces.
- **DTOs:** Define Request/Response types in Feature folders or `types/`.
- **Enums:** Use Enums or Union Types for fixed string values (e.g., Status).

### IMPORTS & ALIASES
- **Mandatory Aliases:**
    - Backend: `@core`, `@config`, `@services`, `@api`, `@utils`
    - Frontend: `@features`, `@components/ui`, `@hooks`, `@lib`
- âŒ **FORBIDDEN:** Deep relative paths (e.g., `../../../../`). Maximum 1 level up (`../`) is allowed, but Aliases are preferred.

### STYLING (Tailwind CSS)
- **Tailwind CSS Only:** No `.css` / `.scss` files for components.
- **Mobile First:** Default styles are mobile; use `md:`, `lg:` for larger screens.

### UI PATTERNS (STRICT)
- **Modals / Dialogs:**
    - **Overlay:** Must utilize `fixed inset-0 z-50 flex items-center justify-center bg-black/50`.
    - **Container:** MUST HAVE EXPLICIT WIDTH (e.g., `w-full max-w-lg`).
    - âŒ **FORBIDDEN:** Narrow/Squashed modals.

### STATE MANAGEMENT & SYNC (STRICT - NO RELOAD POLICY)
- **Instant Feedback:** When a user creates/updates/deletes an item, the UI MUST reflect the change IMMEDIATELY without a page reload.
    - **Method A (Optimistic):** Update the local state list instantly (e.g., `setItems([...items, newItem])`).
    - **Method B (Re-fetch):** Trigger a data re-fetch (`refetch()`) immediately after success.
- **Real-Time Sync:** Critical features (Orders, Stock, Notifications) MUST use **Socket.io** to sync data across devices.

---

## 3. ðŸ› ï¸ TOOLING & RUNTIME (STRICT)

To prevent runtime crashes with Path Aliases (`@core`, `@services`):
1.  **Backend Runtime:** MUST use **`tsx`** (not `ts-node`).
    - Reason: Native support for Alias resolution without configuration hell.
2.  **Start Command:** `"nodemon --exec tsx src/core/server.ts"` (Adjust path if entry file moves).
3.  **Environment:** Ensure `.env` is loaded via `dotenv` or `config` at the very entry point.

---

## 4. ðŸ¤– WORKFLOW FOR AI GENERATION (THE "FULL STACK" PROTOCOL)

When the user requests a new feature (e.g., "Create Voucher System"), you MUST follow this **Vertical Slice** execution path:

1.  **READ & PLAN:**
    - Consult these rules first.
    - Scan `@Codebase` to identify the correct domain folder.

2.  **STEP 1: DATABASE (The Foundation):**
    - Check `prisma/schema.prisma`. Does a model exist for this feature?
    - **IF NO:** You MUST create/update the Prisma Model first.

3.  **STEP 2: BACKEND (The Logic & Sync):**
    - Create **Service** (`@services`) logic.
    - **CRITICAL:** If this data is shared (e.g., new order), the Service MUST emit a Socket.io event (e.g., `io.emit('voucher:created', data)`).
    - Create **Controller** (`@api/controllers`) and **Routes**.

4.  **STEP 3: FRONTEND (The Interface & Sync):**
    - Create UI (Modal/Form) following UI Patterns.
    - Create **Hooks** that:
        - Call the API.
        - **On Success:** Automatically update the list (setList or refetch) -> **NO RELOAD**.
        - **On Socket Event:** Listen for updates to sync with other users.

5.  **REVIEW:**
    - Did I require a page reload to see the new item? -> **FAIL. FIX IT.**
    - Did I skip the Database? -> **STOP & FIX.**

---

**CRITICAL:** A feature is defined as **DONE** only when data is SAVED, and the UI updates INSTANTLY without pressing F5.